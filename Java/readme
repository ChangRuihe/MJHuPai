作者：Thinkraft
链接：https://www.zhihu.com/question/47124225/answer/104955538
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

先进算法当然有啊，http://hp.vector.co.jp/authors/VA046927/mjscore/mjalgorism.html有详细的介绍，思路非常屌爆。大体意思如下（以下掺杂我的个人理解，可能有解释错误之处。会日语的读者请尽量阅读链接原文）：暴力拆解比较吃计算，查表法比较吃内存，虽然这两者对于当今的PC都不是问题，但如果平台机能特别有限，可以采用改进的查表法。基础的查表法，是给每种牌编一个id，麻将中共34种牌因此需要至少6位空间。手牌14张也就是84位。要保存和牌的全部组合约1700万种需要约175MB存储。改进的思路是先给手牌排序，然后不管具体牌面，只计算连续牌的张数，得到一个「牌型」，再从表中查牌型是否胡。例如222456万345678饼北北，可以编码为30111011111102（三张相同牌，三张连续牌，六张连续牌，两张相同牌，中间隔开）。下一步是将其二进制化，采用如下特制规则：

1→0

2→110

3→11110

4→1111110

10→10

20→1110

30→111110

40→11111110

很容易看出，这样编码后每张牌只占用1到2位空间，最恶情况子下（十四张不连单牌）仅占用27位。跟之前的84位相比，单组数据压缩了三分之二以上。更牛逼的是，和牌表从1700万种具体组合下降到仅仅9362种形状排列！另外，作者反复强调：查表时需要大量整型比较运算，将数据控制在32位以内对于（2008年成文当时主流的）32位CPU本身也是优化（省操作次数）。结论上，根据作者测试，优化后的查表算法比暴力拆解快大约50倍，而且速度特别稳定。相对地，传统的拆解法碰上清一色这种同色牌多的牌型会变慢。还有一个是役的计算，分为事后判定（先检查是否和牌、再检查役种）和事前判定（检查和牌的同时检查役种）。文中的算法支持一部分役的事前判定。最后再贴一遍地址：http://hp.vector.co.jp/authors/VA046927/mjscore/mjalgorism.html。文末有全部源码（Java）。